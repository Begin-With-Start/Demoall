apply plugin: 'com.android.library'

android {
    compileSdkVersion 27


    defaultConfig {
        minSdkVersion 16
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'com.android.support:appcompat-v7:27.1.1'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
//这里的“<<”表示追加的意思，即向hello中加入执行过程 我们还可以使用doLast来达到同样的效果：如果需要向Task的最前面加入执行过程，我们可以使用doFirst
// << 操作符就是dolast的短标记形式，可以代替dolast；
//指定group 和 描述，在./gradlew tasks 命令中会打印出来的一个设置；
task outExtMes {
    description = "一个演示dofirst 和 dolast的task"
    group = BasePlugin.BUILD_GROUP
    doFirst {
        println "handframecode outExtMes dofirst "
    }
    doLast {
        println "handframecode outExtMes ：   ${phone}"

        //    脚本中可以放java groovy gradle kotlin 各种语法和语言进来；
        def data = new Date()
        def formatDate = data.format("yyyy-MM-dd")
        println "handframecode outExtMes   :    " + formatDate
    }
}


//不加 << 的时候，会自动被构建调用，<< = dolast
//在一个project中task是互相隔离的，每个build中的task 互相可依赖；
task outExtMesDependon(dependsOn: outExtMes) {
    doFirst {
        println "handframecode outExtMes dofirst "
    }
    doLast {
        String desprition = "im outExtMesDependon's desprition ......."
        println "handframecode dependson outExtMes  ..... 难道就让它自动执行了？"
        println desprition
    }
}


/*
//任务的顺序执行指定问题
1.shouldRunAfter  应该顺序执行，可能不会按照这个顺序来执行，例如在.gradlew 指定运行顺序，那么会按照指定顺序来执行；
2.mustRunAfter  必须顺序执行，一定会按照这个顺序来执行；
*/

task outMesOrder1 {
    println "outMesOrder1 执行了----------"
}

task outMesOrder2 {
    println "outMesOrder2 执行了----------"
}
//一定会按照顺序来执行，而不会管外部指定的顺序；
//outMesOrder1.mustRunAfter(outMesOrder2)

//不一定按照顺序来执行
outMesOrder1.shouldRunAfter(outMesOrder2)


task propertyShow {
    description = ""
    group = BasePlugin.BUILD_GROUP
}
propertyShow.doLast {
    println("propertyShow excute .............")
}
//任务的禁用
propertyShow.enabled = false

//onlyif 断言方式来控制，在某些操作之后再进行下一个操作；
task taskExcuteOnlyIf << {
    println("taskExcuteOnlyIf excute........")
}
taskExcuteOnlyIf.onlyIf {
    def excute = true
    if (true) {
        excute = true
    }
    excute
}
